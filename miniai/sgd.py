# AUTOGENERATED! DO NOT EDIT! File to edit: ../notebooks/12_accel_sgd.ipynb.

# %% auto 0
__all__ = ['BaseSchedCB', 'BatchSchedCB', 'HasLearnCB', 'RecorderCB', 'EpochSchedCB']

# %% ../notebooks/12_accel_sgd.ipynb 1
import torch
import matplotlib.pyplot as plt

from .datasets import *
from .conv import *
from .learner import *
from .activations import *
from .init import *

# %% ../notebooks/12_accel_sgd.ipynb 24
# takes in scheduler callable to be passed the optimizer.
# Must be extended to call _step when required
class BaseSchedCB(Callback):
    def __init__(self, sched): self.sched = sched
    def before_fit(self, learn): self.schedo = self.sched(learn.opt)
    def _step(self, learn):
        if learn.training: self.schedo.step()

# %% ../notebooks/12_accel_sgd.ipynb 25
class BatchSchedCB(BaseSchedCB):
    def after_batch(self, learn): self._step(learn)


# %% ../notebooks/12_accel_sgd.ipynb 26
class HasLearnCB(Callback):
    def before_fit(self, learn): self.learn = learn 
    def after_fit(self, learn): self.learn = None


# %% ../notebooks/12_accel_sgd.ipynb 27
# Takes in functions that will to pull elements off the optimizers param groups
# The callables passed in will recieve a copy of the callback as an argument
# They can then reference the pg element set during before_fit to return an element
# the returned element will be saved to recs which can be plotted
class RecorderCB(Callback):
    def __init__(self, **d): self.d = d
    def before_fit(self, learn):
        self.recs = {k:[] for k in self.d}
        self.pg = learn.opt.param_groups[0]
    
    def after_batch(self, learn):
        if not learn.training: return
        for k,v in self.d.items():
            self.recs[k].append(v(self))

    def plot(self):
        for k,v in self.recs.items():
            plt.plot(v, label=k)
            plt.legend()
            plt.show()

# %% ../notebooks/12_accel_sgd.ipynb 33
class EpochSchedCB(BaseSchedCB):
    def after_epoch(self, learn): self._step(learn)

